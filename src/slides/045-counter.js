import {div, button} from '@cycle/dom';
import {Observable} from 'rx';
import _ from 'lodash';

import md from '../md.js';

import {record, logAnimation, sparkle} from '../visualization';

function view (time, count, addLog, subtractLog, domLog) {
  const text = `
  An example.
  ===

  Cycle.js apps are built on top of Observables (aka streams).

  An Observable represents a stream of future values. For example, events generated by clicking on a button can be considered a stream. Or changes to the DOM over time.

                              <-- time -->
    Add:      ${logAnimation(time, addLog)}
    Subtract: ${logAnimation(time, subtractLog)}
                    V
                    |       +---------------+
             Events +-----> | *   *   *  *  |
            (sources)       | main function |
                            |   *   *   *   | +-----+ DOM updates
                            +---------------+       |   (sinks)
                                                    V
    DOM:      ${logAnimation(time, domLog)}
  `;

  return (
    div('.wrapper', [
      md(sparkle(text, time, addLog, subtractLog), 'counter-diagram'),
      div('.counter', [
        div('.count', `Count: ${count}`),
        button('.subtract', 'Subtract'),
        button('.add', 'Add')
      ])
    ])
  );
}

export default function Counter ({DOM, Animation}) {
  const time$ = Animation
    .pluck('timestamp');

  const add$ = DOM
    .select('.add')
    .events('click')
    .map(() => +1);

  const subtract$ = DOM
    .select('.subtract')
    .events('click')
    .map(() => -1);

  const addLog$ = record(add$, time$);
  const subtractLog$ = record(subtract$, time$);

  const count$ = add$.merge(subtract$)
    .startWith(0)
    .scan((total, change) => total + change);

  const domLog$ = record(count$, time$);

  return {
    DOM: time$.withLatestFrom(count$, addLog$, subtractLog$, domLog$, view)
  };
}
